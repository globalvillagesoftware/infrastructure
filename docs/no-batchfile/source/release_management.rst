##########################
Managing Software Releases
##########################
In this document, we are going to talk about application releases, their
life-cycle andd the process of managing them. This will all be considered at a
high level, so it may lack details. These will be provided later in requirements
documents. This is basically a concepts document. We are looking at an open
source development environment. If you run a closed shop such as the `IT`
department of an enterprise or the computing support facility of an organization
whose only users are members of the orgamization, some elements of this
discussion may need to be modified.

********
Releases
********

What Is a Release?
------------------

A release can be considered an event in a process. It occurs when the management
of the application announce the availability of a new release of the
application. It is the point where application software is ready for use by its'
users. As you will see below, it occurs neither at the beginning nor the end of
the release management process, but in the middle. Each release is identified by
a unique version number :ref:`version`. This helps to allow the concurrent
development of multiple releases.
 
The Release Process
-------------------

Since repository branches are a major tool in the release management process,
you may want to read :ref:`branches` about them before continuing. It will be
easier for you to understandthe implications of some development practices if
you do.

Infrastructure
^^^^^^^^^^^^^^
Many management decisions help to provide the infrastructural underpinnings that
provide the environment within which software development and maintenance takes
place. These decisions determine how the delelopment process is carried out and
can have a strong effect on the quality of the final content generated by the
process.

* Human Management. |br|
  This takes different forms depending on whether the organization involved is
  focused on open source software development or not. All aspects of dealing
  with humans in the context of software development are considered here.

  * Time and activity recording |br| 
    Software development time is distributed across a large number of
    activities. If the software can monitor itself and report what happened, we
    can start to develop an understanding of how softwarre development actually
    takes place. We can see what activites were performed on what tasks, using
    what quantity of resources and we have the opportunity to assess what is
    actually needed to perform certain tasks, particularly when the data is
    consolidated and variances from the norm can be examined. One problem in 
    this area is that data about individuals will be tracked and this can raise
    concerns about privacy. This data can be used by individuals to monitor
    their own performance and to spot possible ways of improving it so it is not
    necesarily an invasive activity. Unfortunately, this data can be used to
    control and intimidate organization members and such use can be difficult to
    detect and control. This form of monitoring should be an optional feature
    that can be turned off at an organization's discretion.
  * Communication |br|
    Good communication between collegues lies at the heart of successful
    software development. This should be built into all *Global Village*
    applications. It should, at least, provide the following capabilities:

    * It should be easy for the communication subsystem to interact with the
      application that is invoking it and gather any data needed for the message
      being constructed. Thus if the appplication is one that manages issues,
      for example, it should be possible to easy to accurately embed any needed
      information about an issue into the message being constructed.
    * The communication subsystem should act in both a synchronous and
      asynchronous manner, storing messages until the recipient is ready to see
      them.
    * The communication subsystem should be available 24/7.
    * The communication subsystem should support multiple organizations and
      allow communication between organizations as well as within organizations.
    * The communication subsystem should be cost-free to the organization using
      it, aside from providing any necessary organization based hardware. It
      should be available as a shared subsystem using *Global Village*
      facilities.
    * The shared components of the communication subsystem should be installable
      and operable locally within an organization if privacy is a problem. It is
      not necessary to provide full inter-organization communication in this
      case.

  * Security |br| 
    If you want to ensure the integrity of your application, you need to be sure
    that ony the people authorized to do so work on it. So long as you trust the
    people involved, you can have a reasonable expectation that no undesired
    capability will be introduced into the application. Two aspects of security
    are particularly important:
    
    * Ability to securely identify organization personnel in the development
      environment. |br| 
    * Ability to control whar activities are permitted, based on the identity of
      the orgaanization member. |br| 
    * Control the configuration of computers used for software development. |br| 

      * Ensure consistency. |br| 
      * Ensure portability. |br| 
      * Ensure usability. |br|
       
    * Provide consistent working environments
      for geographically dispersed teams. |br| 

* Provide source code repositories and the
  tools to effectively manage them. |br| 

Cycle
^^^^^

The release process is a cycle that repeats itself many times. Each cycle
produces and maintains a single release of an application. Each cycle has phases
that are described below.

Development
"""""""""""

Deployment
""""""""""

Use
"""

Maintenance
"""""""""""

Withdrawal
""""""""""

.. _branches:

*******************
Repository Branches
*******************
|gv| makes heavy use of a repository management system. Here is a high-level
view of of of its' major features and why it is a help to application release
management.
 
Background
----------
The fundamental reason for the existence of `branches` in a repository manager
is to provide a mechanism to ensure that development and maintenance work does
not corrupt the deployed software. A branch is essentially a copy of the core
data in the repository. You can develop and test new functionality or do
maintenance in a branch without impacting the integrity of the core code and
data that make up the current version of the delivered application. Once the new
functionality has been developed and tested, it is ready for integration into
the main application. This is done through a new process called `merging` that
puts the new code and data into the main code for the application. Note that
this does not happen until all code has completed development and been tested.
Testing checks both the existing and the new functionality. This ensures that
the new code does not break any existing functionality.

Use of Branches
---------------
Branches in a repository each have a name which can be anything that you want.
Conventions, however, have developed over time. The production application code
is normally kept in a branch called `master`. This is is the default branch
within most repositories. Most organizations also create a branch called
`development`. The purpose of this branch is to hold all code that will become
part of the next release. The same problem exists during the development cycle
as does during production. With potentially many people working on the next
software release at the same time, it becomes necessary to deal with the problem
of developers accidentally interfering with the work of other developers.

Topic Branches
^^^^^^^^^^^^^^
This is solved by creating additional branches, called `topic` branches, on top
of the `development` branch. Each individual piece of functionality or
maintenances is given its' own `topic` branch which is where work on the feature
takes place. When development and testing on a `topic` branch is complete, the
`topic` branch is merged into the `development` branch and so becomes part
of the content of the next application release. When the `topic` branch has been
sucessfully merged, it is put to bed and is no longer used. The productive life
of a `topic` branch is that of the feature that is being developed only. `Topic`
branches normally stay around after the feature is completely developed, but
they are kept for historical reasons only and are no longer used.

Release Management
^^^^^^^^^^^^^^^^^^
A release happens when a new version of the application software is made
available to the application users. These releases always come from the `master`
branch. The point at which the new release is successfully accomplished is given
a `tag` within the repository which is a named point in the history of the main
branch and allows for the retrieval of the code that was associated with a
particular release.

Thus, over time, the `master` branch will acquire a series of `tags` that will
identify each release of the application software. The `development` branch is
associated with a particular release and the release version number will form
part of the name of the `development` branch. Once a release is made,
the `development` branch is no longer used and a new `development` branch is
created for the next release. This cycle repeats adinfinitum.

Patch Branches
^^^^^^^^^^^^^^
Once a release is put into production and starts being used, problems are
encountered and reported. Fixing most of these problems can be deferred to the
next scheduled release and the work needed to fix them can become part of the
normal development cycle for the next release. However, it may turn out that
some problems  are critical and must be addressed immediately. These problems
do not fall into the normal pattern of development and must be handled in a
special way.

Special branches called `patch` branches are created from the `HEAD` of the
current `master` branch. This is done to ensure that there are no major
breakages between the `patch` and the `master` branches. It also potentially
shortens the time needed to develop a `patch` release since no attention is paid
to the next release. Once the patch has been fully tested, a new `patch` release
of the application can be made. Work on the `patch` is not complete yet. It
still needs to be checked against the current `development` branch to ensure
that it does not affect the next release and that it continues to supply the
needed `patch` functionality. Note that `tags` are created on the `master`
branch for each `patch` release.

The process continues by done by merging the `patch` branch with the current
`development` branch and then testing that the `patch` still works and that the
`development` branch is not corrupted in any way.
